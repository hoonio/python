from appscript import *import __builtin__class MyTunes:	def __init__(self):		""" no arguments -> MyTunes handle		creates a new MyTunes bridge object		Save this value in a variable for future use, e.g.		itunes = mytunes.MyTunes()		"""		self.__app = app('iTunes')		def start(self):		""" no arguments -> None		starts iTunes playing"""		try:			self.__app.play()		except:			pass			def pause(self):		"""no arguments -> None		pauses the currently  playing track		"""		try:			self.__app.pause()		except:			pass		def stop(self):		"""no arguments -> None		stops the currently playing track		"""		try:			self.__app.stop()		except:			pass		def next_track(self):		""" no arguments -> None, 		moves to the next track in the current playlist """		try:			self.__app.next_track()		except:			pass		def previous_track(self):		""" no arguments -> None		moves to the previous track in the current playlist """		try:			self.__app.previous_track()		except:			pass				def set_volume(self, value):		"""integer between 0 and 100 -> None		Sets the volume		"""		try:			self.__app.sound_volume.set(value)		except:			print "Error setting volume. Skipping"			pass				def get_volume(self):		"""no arguments -> integer		Returns the current value of the volume setting		"""		try:			return self.__app.sound_volume.get()		except:			return -1			def play_playlist(self, pl_name):		"""playlist_name -> None		Starts playing the named playlist """		try:			pl = self.__app.playlists[pl_name]			self.__app.play(pl)		except:			print "No such playlist %s" % pl_name		def play_track(self, track_idx):		"""track_name or number -> None		Starts playing the indicated track, within the current playlist.		"""		try:			tracks = self.__app.current_playlist.tracks.get()			if track_idx >= len(tracks):				print "Index out of bounds [0:%s)" % len(tracks)				return			track = tracks[track_idx]			self.__app.play(track)		except:			print "No such track %s" % track_name		def track_length(self):		"""no arguments -> list of track_names, 		Returns a list of strings for the currently playing playlist.		"""		try:			tracks = self.__app.current_playlist.tracks.duration.get()			return tracks		except:			print "Error retrieving tracks"				def current_tracks(self):		"""no arguments -> list of track_names, 		Returns a list of strings for the currently playing playlist.		"""		try:			tracks = self.__app.current_playlist.tracks.name.get()			return tracks		except:			print "Error retrieving tracks"				def current_track(self):		"""no arguments -> dictionary		Returns a dictionary of information		regarding the current track		"""				track_fields = ['album', 'artist', 'bit_rate', 'bpm', 'comment',				'compilation', 'composer', 'database_ID',				'date_added', 'disc_count', 'disc_number',				'duration', 'enabled', 'EQ', 'finish', 'genre',				'grouping', 'kind', 'modification_date',				'played_count', 'played_date',				'rating', 'sample_rate', 'size', 'start',				'time', 'track_count', 'track_number'				'volume_adjustment', 'year',				'name', 'location', 'container']							try:			result = {}			track = self.__app.current_track.get()			for field_name in track_fields:				try:					if hasattr(track, field_name):						result[field_name] = getattr(track, field_name).get()				except:					pass			return result		except:			print "Error getting track info."			return result		def track_info(self, track_name):		"""track_name -> dictionary		Returns dictionary of information regarding		the named track if it exists, otherwise an empty dictionary		"""				try:			track = self.__app.library_playlists.get()[0].tracks[track_name].get()			track_fields = ['album', 'artist', 'bit_rate', 'bpm', 'comment',				'compilation', 'composer', 'database_ID',				'date_added', 'disc_count', 'disc_number',				'duration', 'enabled', 'EQ', 'finish', 'genre',				'grouping', 'kind', 'modification_date',				'played_count', 'played_date',				'rating', 'sample_rate', 'size', 'start',				'time', 'track_count', 'track_number'				'volume_adjustment', 'year',				'name', 'location', 'container']										result = {}			for field_name in track_fields:				try:					if hasattr(track, field_name):						result[field_name] = getattr(track, field_name).get()				except:					pass			return result		except Exception, e:			print "Error getting track info"			return {}			def all_playlist_names(self):		"""No arguments -> list of strings		Returns a list of the names of all of the playlist		names in the iTunes database."""				try:			return self.__app.sources['Library'].user_playlists.name.get()		except:			return []				def all_track_names(self):		"""No arguments -> list of strings, 		Returns a list of the names of all of the track		names in the iTunes database."""				try:			names = []			for pl_name in self.all_playlist_names():				tracks = self.__app.playlists[pl_name].tracks.get()				if not tracks: continue				names.extend(self.__app.playlists[pl_name].tracks.name.get())			return names		except Exception, e:			print "Error", e			return []		def get_playlist(self, idx):		"""playlist_name or playlist_number -> list of strings		Returns a list of all the names in the named playlist, if the playlist exists.		"""				try:			pl = self.__app.user_playlists[idx].get()			results = []			for track in pl.tracks.get():				results.append(track.name.get())			return results		except:			return []				def __playlist_object(self, idx):		try:			playlists = self.__app.user_playlists.get()			pl = None			if isinstance(idx, str):				pl = self.app.user_playlists[idx]			elif isinstance(idx, int):				if ((0 <= idx) and (idx < len(playlists))):					pl = playlists[idx]		 			return pl		except:			return			def help():	for attr_name in dir(MyTunes):		if attr_name[0] != "_":			__builtin__.help(getattr(MyTunes, attr_name))											